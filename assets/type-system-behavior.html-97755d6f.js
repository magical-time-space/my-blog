const e=JSON.parse('{"key":"v-a620f34a","path":"/views/Books/Front-end/TypescriptMaster/faqs/type-system-behavior.html","title":"类型系统的行为","lang":"zh-CN","frontmatter":{"description":"类型系统的行为 什么是结构化类型？ TypeScript 使用结构化类型，这个系统并不同于你可能使用过的一些其他流行语言（如：Java、C# 等）的类型系统。 结构化类型系统背后的思想是如果他们的成员类型是兼容的，则他们是兼容的。例如：在 C# 或者 Java 中，有两个名为 MyPoint 和 YourPoint 的类，它们都具有公共 int 类型的属性 x 和 y，这两个类是不可互换的。但在结构化的类型系统中（TypeScript），这些类型具有不同名称的事实并不重要，因为它们具有相同类型的成员，所以它们是相同的（可以互换的）。","head":[["meta",{"property":"og:url","content":"https://mpbug.gitee.io/views/Books/Front-end/TypescriptMaster/faqs/type-system-behavior.html"}],["meta",{"property":"og:site_name","content":"魔法Bug"}],["meta",{"property":"og:title","content":"类型系统的行为"}],["meta",{"property":"og:description","content":"类型系统的行为 什么是结构化类型？ TypeScript 使用结构化类型，这个系统并不同于你可能使用过的一些其他流行语言（如：Java、C# 等）的类型系统。 结构化类型系统背后的思想是如果他们的成员类型是兼容的，则他们是兼容的。例如：在 C# 或者 Java 中，有两个名为 MyPoint 和 YourPoint 的类，它们都具有公共 int 类型的属性 x 和 y，这两个类是不可互换的。但在结构化的类型系统中（TypeScript），这些类型具有不同名称的事实并不重要，因为它们具有相同类型的成员，所以它们是相同的（可以互换的）。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"魔法时空宝库"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类型系统的行为\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"魔法时空宝库\\",\\"url\\":\\"https://mpbug.gitee.io/player/\\"}]}"]]},"headers":[{"level":2,"title":"什么是结构化类型？","slug":"什么是结构化类型","link":"#什么是结构化类型","children":[]},{"level":2,"title":"什么是类型删除？","slug":"什么是类型删除","link":"#什么是类型删除","children":[]},{"level":2,"title":"为什么没有 setter 时的 getter，没有被认为是只读？","slug":"为什么没有-setter-时的-getter-没有被认为是只读","link":"#为什么没有-setter-时的-getter-没有被认为是只读","children":[]},{"level":2,"title":"为什么函数参数是双向协变？","slug":"为什么函数参数是双向协变","link":"#为什么函数参数是双向协变","children":[]},{"level":2,"title":"为什么有更少参数的函数能够赋值给具有更多参数的函数？","slug":"为什么有更少参数的函数能够赋值给具有更多参数的函数","link":"#为什么有更少参数的函数能够赋值给具有更多参数的函数","children":[]},{"level":2,"title":"为什么一个返回值不是 void 的函数，可以赋值给一个返回值为 void 的函数？","slug":"为什么一个返回值不是-void-的函数-可以赋值给一个返回值为-void-的函数","link":"#为什么一个返回值不是-void-的函数-可以赋值给一个返回值为-void-的函数","children":[]},{"level":2,"title":"为什么所有的类型，都能赋值给一个空的接口？","slug":"为什么所有的类型-都能赋值给一个空的接口","link":"#为什么所有的类型-都能赋值给一个空的接口","children":[]},{"level":2,"title":"我可以用名义上的类型别名吗？","slug":"我可以用名义上的类型别名吗","link":"#我可以用名义上的类型别名吗","children":[]},{"level":2,"title":"如何防止两种类型在结构上兼容？","slug":"如何防止两种类型在结构上兼容","link":"#如何防止两种类型在结构上兼容","children":[]},{"level":2,"title":"如果对象实现了某个接口，我怎么在运行时检查？","slug":"如果对象实现了某个接口-我怎么在运行时检查","link":"#如果对象实现了某个接口-我怎么在运行时检查","children":[]},{"level":2,"title":"为什么错误的转化不会引起运行时的错误？","slug":"为什么错误的转化不会引起运行时的错误","link":"#为什么错误的转化不会引起运行时的错误","children":[]},{"level":2,"title":"为什么我没有为 (number) => string 或者 (T) => T 进行类型检查？","slug":"为什么我没有为-number-string-或者-t-t-进行类型检查","link":"#为什么我没有为-number-string-或者-t-t-进行类型检查","children":[]},{"level":2,"title":"为什么我会得到 Supplied parameters do not match any signature 的错误？","slug":"为什么我会得到-supplied-parameters-do-not-match-any-signature-的错误","link":"#为什么我会得到-supplied-parameters-do-not-match-any-signature-的错误","children":[]}],"git":{},"readingTime":{"minutes":10.74,"words":3223},"filePathRelative":"views/Books/Front-end/TypescriptMaster/faqs/type-system-behavior.md","excerpt":"<h1> 类型系统的行为</h1>\\n<h2> 什么是结构化类型？</h2>\\n<p>TypeScript 使用<strong>结构化类型</strong>，这个系统并不同于你可能使用过的一些其他流行语言（如：Java、C# 等）的类型系统。</p>\\n<p>结构化类型系统背后的思想是如果他们的成员类型是兼容的，则他们是兼容的。例如：在 C# 或者 Java 中，有两个名为 <code>MyPoint</code> 和 <code>YourPoint</code> 的类，它们都具有公共 <code>int</code> 类型的属性 <code>x</code> 和 <code>y</code>，这两个类是不可互换的。但在结构化的类型系统中（TypeScript），这些类型具有不同名称的事实并不重要，因为它们具有相同类型的成员，所以它们是相同的（可以互换的）。</p>","autoDesc":true}');export{e as data};
