import{_ as r,X as p,Y as l,Z as n,$ as s,a0 as e,a5 as d,a4 as o,E as t}from"./framework-d8252107.js";const u={},k=o(`<p>本章我们会讲解<code>Fiber节点</code>是如何被创建并构建<code>Fiber树</code>的。</p><p><code>render阶段</code>开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>方法的调用。这取决于本次更新是同步更新还是异步更新。</p><p>我们现在还不需要学习这两个方法，只需要知道在这两个方法中会调用如下两个方法：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// performSyncWorkOnRoot会调用该方法</span>
<span class="token keyword">function</span> <span class="token function">workLoopSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// performConcurrentWorkOnRoot会调用该方法</span>
<span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，他们唯一的区别是是否调用<code>shouldYield</code>。如果当前浏览器帧没有剩余时间，<code>shouldYield</code>会中止循环，直到浏览器有空闲时间后再继续遍历。</p><p><code>workInProgress</code>代表当前已创建的<code>workInProgress fiber</code>。</p><p><code>performUnitOfWork</code>方法会创建下一个<code>Fiber节点</code>并赋值给<code>workInProgress</code>，并将<code>workInProgress</code>与已创建的<code>Fiber节点</code>连接起来构成<code>Fiber树</code>。</p>`,7),b={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1599",target:"_blank",rel:"noopener noreferrer"},m=n("code",null,"workLoopConcurrent",-1),v=n("p",null,[s("我们知道"),n("code",null,"Fiber Reconciler"),s("是从"),n("code",null,"Stack Reconciler"),s("重构而来，通过遍历的方式实现可中断的递归，所以"),n("code",null,"performUnitOfWork"),s("的工作可以分为两部分：“递”和“归”。")],-1),h=n("h2",{id:"递-阶段",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#递-阶段","aria-hidden":"true"},"#"),s(" “递”阶段")],-1),f=n("code",null,"rootFiber",-1),_=n("code",null,"Fiber节点",-1),g={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058",target:"_blank",rel:"noopener noreferrer"},w=n("p",null,[s("该方法会根据传入的"),n("code",null,"Fiber节点"),s("创建"),n("code",null,"子Fiber节点"),s("，并将这两个"),n("code",null,"Fiber节点"),s("连接起来。")],-1),F=n("p",null,"当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。",-1),W=n("h2",{id:"归-阶段",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#归-阶段","aria-hidden":"true"},"#"),s(" “归”阶段")],-1),y={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652",target:"_blank",rel:"noopener noreferrer"},R=n("code",null,"Fiber节点",-1),x=o(`<p>当某个<code>Fiber节点</code>执行完<code>completeWork</code>，如果其存在<code>兄弟Fiber节点</code>（即<code>fiber.sibling !== null</code>），会进入其<code>兄弟Fiber</code>的“递”阶段。</p><p>如果不存在<code>兄弟Fiber</code>，会进入<code>父级Fiber</code>的“归”阶段。</p><p>“递”和“归”阶段会交错执行直到“归”到<code>rootFiber</code>。至此，<code>render阶段</code>的工作就结束了。</p><h2 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h2><p>以上一节的例子举例：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      i am
      <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>KaSong<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6),j=n("code",null,"Fiber树",-1),O=["src"],I=o(`<p><code>render阶段</code>会依次执行：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>. rootFiber beginWork
<span class="token number">2</span>. App Fiber beginWork
<span class="token number">3</span>. div Fiber beginWork
<span class="token number">4</span>. <span class="token string">&quot;i am&quot;</span> Fiber beginWork
<span class="token number">5</span>. <span class="token string">&quot;i am&quot;</span> Fiber completeWork
<span class="token number">6</span>. span Fiber beginWork
<span class="token number">7</span>. span Fiber completeWork
<span class="token number">8</span>. div Fiber completeWork
<span class="token number">9</span>. App Fiber completeWork
<span class="token number">10</span>. rootFiber completeWork
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">注意</p><p>之所以没有 “KaSong” Fiber 的 beginWork/completeWork，是因为作为一种性能优化手段，针对只有单一文本子节点的<code>Fiber</code>，<code>React</code>会特殊处理。</p></div>`,3),L={class:"hint-container details"},U=n("summary",null,"自己试一试 Demo",-1),P=n("p",null,[s("我在"),n("code",null,"beginWork"),s("和"),n("code",null,"completeWork"),s("调用时打印"),n("code",null,"fiber.tag"),s("和"),n("code",null,"fiber.type"),s("。")],-1),q={href:"https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactWorkTags.js",target:"_blank",rel:"noopener noreferrer"},B=n("code",null,"Fiber节点",-1),C=n("code",null,"tag",-1),S=n("p",null,"相信多调试几次，你一定能明白方法的调用顺序",-1),E=n("strong",null,"904",-1),A=o(`<details class="hint-container details"><summary>performUnitOfWork 的递归版本</summary><p>如果将<code>performUnitOfWork</code>转化为递归版本，大体代码如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 执行beginWork</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 执行completeWork</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本节我们介绍了<code>render阶段</code>会调用的方法。在接下来两节中，我们会讲解<code>beginWork</code>和<code>completeWork</code>做的具体工作。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>`,4),N={href:"https://indepth.dev/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree/",target:"_blank",rel:"noopener noreferrer"},T={href:"https://indepth.dev/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react/",target:"_blank",rel:"noopener noreferrer"};function V(c,Y){const a=t("ExternalLinkIcon"),i=t("RouterLink");return p(),l("div",null,[k,n("blockquote",null,[n("p",null,[s("你可以从"),n("a",b,[s("这里"),e(a)]),s("看到"),m,s("的源码")])]),v,h,n("p",null,[s("首先从"),f,s("开始向下深度优先遍历。为遍历到的每个"),_,s("调用"),n("a",g,[s("beginWork方法"),e(a)]),s("。")]),w,F,W,n("p",null,[s("在“归”阶段会调用"),n("a",y,[s("completeWork"),e(a)]),s("处理"),R,s("。")]),x,n("p",null,[s("对应的"),j,s("结构： "),n("img",{src:c.$withBase("/img/fiber.png"),alt:"Fiber架构"},null,8,O)]),I,n("details",L,[U,P,n("p",null,[s("你可以从"),n("a",q,[s("ReactWorkTags.js"),e(a)]),s("看到"),B,s("的所有"),C,s("定义。")]),S,n("p",null,[e(i,{to:"/views/Books/Front-end/JustReact/me.html"},{default:d(()=>[s("关注公众号")]),_:1}),s("，后台回复"),E,s("获得在线Demo地址")])]),A,n("p",null,[n("a",N,[s("The how and why on React’s usage of linked list in Fiber to walk the component’s tree"),e(a)])]),n("p",null,[n("a",T,[s("Inside Fiber: in-depth overview of the new reconciliation algorithm in React"),e(a)])])])}const K=r(u,[["render",V],["__file","reconciler.html.vue"]]);export{K as default};
