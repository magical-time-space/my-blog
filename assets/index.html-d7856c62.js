const e=JSON.parse('{"key":"v-9eb51308","path":"/views/Books/Front-end/JustVue2/compile/","title":"编译","lang":"zh-CN","frontmatter":{"description":"编译 之前我们分析过模板到真实 DOM 渲染的过程，中间有一个环节是把模板编译成 render 函数，这个过程我们把它称作编译。 虽然我们可以直接为组件编写 render 函数，但是编写 template 模板更加直观，也更符合我们的开发习惯。 Vue.js 提供了 2 个版本，一个是 Runtime + Compiler 的，一个是 Runtime only 的，前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助 webpack 的 vue-loader 事先把模板编译成 render 函数。","head":[["meta",{"property":"og:url","content":"https://mpbug.gitee.io/views/Books/Front-end/JustVue2/compile/"}],["meta",{"property":"og:site_name","content":"魔法Bug"}],["meta",{"property":"og:title","content":"编译"}],["meta",{"property":"og:description","content":"编译 之前我们分析过模板到真实 DOM 渲染的过程，中间有一个环节是把模板编译成 render 函数，这个过程我们把它称作编译。 虽然我们可以直接为组件编写 render 函数，但是编写 template 模板更加直观，也更符合我们的开发习惯。 Vue.js 提供了 2 个版本，一个是 Runtime + Compiler 的，一个是 Runtime only 的，前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助 webpack 的 vue-loader 事先把模板编译成 render 函数。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"魔法时空宝库"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"编译\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"魔法时空宝库\\",\\"url\\":\\"https://mpbug.gitee.io/player/\\"}]}"]]},"headers":[],"git":{},"readingTime":{"minutes":0.95,"words":285},"filePathRelative":"views/Books/Front-end/JustVue2/compile/index.md","excerpt":"<h1> 编译</h1>\\n<p>之前我们分析过模板到真实 DOM 渲染的过程，中间有一个环节是把模板编译成 <code>render</code> 函数，这个过程我们把它称作编译。</p>\\n<p>虽然我们可以直接为组件编写 <code>render</code> 函数，但是编写 <code>template</code> 模板更加直观，也更符合我们的开发习惯。</p>\\n<p>Vue.js 提供了 2 个版本，一个是 Runtime + Compiler 的，一个是 Runtime only 的，前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助 webpack 的 <code>vue-loader</code> 事先把模板编译成 <code>render </code>函数。</p>","autoDesc":true}');export{e as data};
