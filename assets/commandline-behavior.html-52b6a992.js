import{_ as o,X as t,Y as c,Z as e,$ as n,a0 as a,a4 as r,E as i}from"./framework-d8252107.js";const d={},p=e("h1",{id:"命令行的行为",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#命令行的行为","aria-hidden":"true"},"#"),n(" 命令行的行为")],-1),l=e("h2",{id:"如何控制输出文件中的排序-out",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#如何控制输出文件中的排序-out","aria-hidden":"true"},"#"),n(" 如何控制输出文件中的排序（-- out）？")],-1),u=e("p",null,"输出文件的排序遵循预处理后输入文件的顺序。",-1),h=e("p",null,"编译器执行预处理，主要是为了解决所有的三斜线指令和模块导入。在这个过程中，额外的文件将会被将入到编译过程中。",-1),m=e("p",null,[n("这个过程开始于一个给定的根文件，这些是在命令行或者是 "),e("code",null,"tsconfig.json"),n(" 文件中 files 指定文件名，这些根文件按照指定的顺序进行预处理。在一个文件添加到这个列表之前，将处理所有的三斜线引用和模块导入语法，并包括它们的目标。三斜线引用和导入语法按照它们在文件中出现的顺序，以深度优先的方式解析。")],-1),k={href:"https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.typescriptlang.org/docs/handbook/module-resolution.html",target:"_blank",rel:"noopener noreferrer"},_=r(`<h2 id="exported-variable-name-has-or-is-using-private-name-name-是什么错误" tabindex="-1"><a class="header-anchor" href="#exported-variable-name-has-or-is-using-private-name-name-是什么错误" aria-hidden="true">#</a> <code>Exported variable [name] has or is using private name [name]</code> 是什么错误？</h2><p>当你使用 <code>--declarartion</code> 编译选项的时候，可能会出现这个错误，因为编译器试图生成与你定义模块完全匹配的声明文件：</p><p>假设你有这样一段代码：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">/// MyFile.ts</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... other members ....</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> parent<span class="token operator">:</span> Test<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token string">&#39;some thing&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了生成声明文件，编译器必须为 <code>t</code> 写一个类型：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">/// MyFile.d.ts, auto-generated</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> t<span class="token operator">:</span> ___fill <span class="token keyword">in</span> the blank___<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>成员 <code>t</code> 有类型 <code>Test</code>，但是类型 <code>Test</code> 并不是可见的，因为它没有导出，因此我们不能写 <code>t: Test</code>。</p><p>在这个非常简单的例子里，我们可以用一个对象字面量重写 <code>Test&#39;s</code> 的形状。但是对于绝大多数情况，这并不能正常工作。如代码里所写，Test 的形状是自引用的，不能重写为匿名函数。如果 <code>Test</code> 有任何私有或受保护的成员，这同样也不能正常工作。因此，与其让你通过编写一个真实的类来获得 65% 的成功而后开始抛出错误，我们仅仅是在一开始的时候就抛出错误（你以后会发现）并为你省去不必要的麻烦。</p><p>为了避免这些错误：</p><ul><li>导出相关类型中使用的声明</li><li>当编写声明的时候，显示的为编译器指定类型注解</li></ul><h2 id="为什么添加-outdir-属性后-当在添加一个新文件时-会把所有的输出删除" tabindex="-1"><a class="header-anchor" href="#为什么添加-outdir-属性后-当在添加一个新文件时-会把所有的输出删除" aria-hidden="true">#</a> 为什么添加 <code>--outDir</code> 属性后，当在添加一个新文件时，会把所有的输出删除</h2><p><code>--outDir</code> 指定输出的「根」目录。编译器需要此属性，用来将资源映射输出到根目录。如果 <code>--rootDir</code> 没有被指定，编辑器将会自己计算出一个。它根据常见的路径计算，它是所有输入文件的最长公共前缀。显然，当在较短路径前缀中添加新文件时，<code>--rootDir</code> 将会被修改。</p><p>为了确保添加一个新文件时，输出不会被修改，你应该在命令行中或 <code>tsconfig.json</code> 指定一个 <code>--rootDir</code>。</p>`,13);function b(g,f){const s=i("ExternalLinkIcon");return t(),c("div",null,[p,l,u,h,m,e("p",null,[n("请参考有关"),e("a",k,[n("三斜线指令"),a(s)]),n("的更多信息，和"),e("a",v,[n("模块"),a(s)]),n("导入语法的信息。")]),_])}const y=o(d,[["render",b],["__file","commandline-behavior.html.vue"]]);export{y as default};
