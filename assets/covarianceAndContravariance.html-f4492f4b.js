import{_ as t,X as r,Y as a,Z as e,$ as o,a0 as d,a4 as n,E as i}from"./framework-d8252107.js";const l={},s=e("h1",{id:"协变与逆变",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#协变与逆变","aria-hidden":"true"},"#"),o(" 协变与逆变")],-1),p={href:"https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance",target:"_blank",rel:"noopener noreferrer"},h={href:"https://en.wikipedia.org/wiki/Subtyping",target:"_blank",rel:"noopener noreferrer"},_=e("em",null,"协变",-1),g=e("em",null,"逆变",-1),u=n('<p>开始文章之前我们先约定如下的标记：</p><ul><li><code>A ≼ B</code> 意味着 <code>A</code> 是 <code>B</code> 的子类型。</li><li><code>A → B</code> 指的是以 <code>A</code> 为参数类型，以 <code>B</code> 为返回值类型的函数类型。</li><li><code>x : A</code> 意味着 <code>x</code> 的类型为 <code>A</code>。</li></ul><h2 id="一个有趣的问题" tabindex="-1"><a class="header-anchor" href="#一个有趣的问题" aria-hidden="true">#</a> 一个有趣的问题</h2><p>假设我有如下三种类型：</p><blockquote><p><code>Greyhound ≼ Dog ≼ Animal</code></p></blockquote><p><code>Greyhound</code> （灰狗）是 <code>Dog</code> （狗）的子类型，而 <code>Dog</code> 则是 <code>Animal</code> （动物）的子类型。由于子类型通常是可传递的，因此我们也称 <code>Greyhound</code> 是 <code>Animal</code> 的子类型。</p><p><strong>问题</strong>：以下哪种类型是 <code>Dog → Dog</code> 的子类型呢？</p><ol><li><code>Greyhound → Greyhound</code></li><li><code>Greyhound → Animal</code></li><li><code>Animal → Animal</code></li><li><code>Animal → Greyhound</code></li></ol><p>让我们来思考一下如何解答这个问题。首先我们假设 <code>f</code> 是一个以 <code>Dog → Dog</code> 为参数的函数。它的返回值并不重要，为了具体描述问题，我们假设函数结构体是这样的： <code>f : (Dog → Dog) → String</code>。</p><p>现在我想给函数 <code>f</code> 传入某个函数 <code>g</code> 来调用。我们来瞧瞧当 <code>g</code> 为以上四种类型时，会发生什么情况。</p><p><strong>1. 我们假设 <code>g : Greyhound → Greyhound</code>， <code>f(g)</code> 的类型是否安全？</strong></p><p>不安全，因为在f内调用它的参数<code>(g)</code>函数时，使用的参数可能是一个不同于灰狗但又是狗的子类型，例如 <code>GermanShepherd</code> （牧羊犬）。</p><p><strong>2. 我们假设 <code>g : Greyhound → Animal</code>， <code>f(g)</code> 的类型是否安全？</strong></p><p>不安全。理由同(1)。</p><p><strong>3. 我们假设 <code>g : Animal → Animal</code>， <code>f(g)</code> 的类型是否安全？</strong></p><p>不安全。因为 <code>f</code> 有可能在调用完参数之后，让返回值，也就是 <code>Animal</code> （动物）狗叫。并非所有动物都会狗叫。</p><p><strong>4. 我们假设 <code>g : Animal → Greyhound</code>， <code>f(g)</code> 的类型是否安全？</strong></p><p>是的，它的类型是安全的。首先，<code>f</code> 可能会以任何狗的品种来作为参数调用，而所有的狗都是动物。其次，它可能会假设结果是一条狗，而所有的灰狗都是狗。</p><h2 id="展开讲讲" tabindex="-1"><a class="header-anchor" href="#展开讲讲" aria-hidden="true">#</a> 展开讲讲？</h2><p>如上所述，我们得出结论：</p><blockquote><p><code>(Animal → Greyhound) ≼ (Dog → Dog)</code></p></blockquote><p>返回值类型很容易理解：灰狗是狗的子类型。但参数类型则是相反的：动物是狗的<em>父类</em>！</p><p>用合适的术语来描述这个奇怪的表现，可以说我们允许一个函数类型中，返回值类型是<em>协变</em>的，而参数类型是<em>逆变</em>的。返回值类型是协变的，意思是 <code>A ≼ B</code> 就意味着 <code>(T → A) ≼ (T → B)</code> 。参数类型是逆变的，意思是 <code>A ≼ B</code> 就意味着 <code>(B → T) ≼ (A → T)</code> （ <code>A</code> 和 <code>B</code> 的位置颠倒过来了）。</p>',23),m=e("strong",null,"一个有趣的现象",-1),f=e("code",null,"TypeScript",-1),A={href:"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-function-parameters-bivariant",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html",target:"_blank",rel:"noopener noreferrer"},y=e("code",null,"TypeScript 2.6",-1),k=e("code",null,"--strictFunctionTypes",-1),v=e("code",null,"--strict",-1),w=n('<h2 id="那其他类型呢" tabindex="-1"><a class="header-anchor" href="#那其他类型呢" aria-hidden="true">#</a> 那其他类型呢？</h2><p><strong>问题</strong>：<code>List&lt;Dog&gt;</code> 能否为 <code>List&lt;Animal&gt;</code> 的子类型？</p><p>答案有点微妙。如果列表是不可变的（immutable），那么答案是肯定的，因为类型很安全。但是假如列表是可变的，那么答案绝对是否定的！</p><p>原因是，假设我需要一串 <code>List&lt;Animal&gt;</code> 而你传给我一串 <code>List&lt;Dog&gt;</code>。由于我认为我拥有的是一串 <code>List&lt;Animal&gt;</code> ，我可能会尝试往列表插入一只 <code>Cat</code>。那么你的 <code>List&lt;Dog&gt;</code> 里面就会有一只猫！类型系统不应该允许这种情况发生。</p><p>总结一下，我们可以允许不变的列表（immutable）在它的参数类型上是协变的，但是对于可变的列表（mutable），其参数类型则必须是不变的（invariant），既不是协变也不是逆变。</p>',5),D=e("strong",null,"一个有趣的现象",-1),G=e("code",null,"Java",-1),x={href:"https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29#Covariant_arrays_in_Java_and_C.23",target:"_blank",rel:"noopener noreferrer"};function B(T,L){const c=i("ExternalLinkIcon");return r(),a("div",null,[s,e("blockquote",null,[e("p",null,[e("a",p,[o("原文链接: what are covariance and contravariance"),d(c)])])]),e("p",null,[e("a",h,[o("子类型"),d(c)]),o(" 在编程理论上是一个复杂的话题，而他的复杂之处来自于一对经常会被混淆的现象，我们称之为"),_,o("与"),g,o("。这篇文章将会解释上述两个概念。")]),u,e("p",null,[m,o("：在 "),f,o(" 中， "),e("a",A,[o("参数类型是双向协变的"),d(c)]),o(" ，也就是说既是协变又是逆变的，而这并不安全。但是现在你可以在 "),e("a",b,[y,d(c)]),o(" 版本中通过 "),k,o(" 或 "),v,o(" 标记来修复这个问题。")]),w,e("p",null,[D,o("：在 "),G,o(" 中，数组"),e("a",x,[o("既是可变的，又是协变的"),d(c)]),o("。当然，这并不安全。")])])}const S=t(l,[["render",B],["__file","covarianceAndContravariance.html.vue"]]);export{S as default};
