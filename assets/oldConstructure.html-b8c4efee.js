import{_ as a,X as d,Y as i,Z as e,$ as t,a0 as o,a5 as h,a4 as r,E as s}from"./framework-d8252107.js";const _={},p=r('<p>在上一节中我们了解了<code>React</code>的理念，简单概括就是<strong>快速响应</strong>。</p><p><code>React</code>从v15升级到v16后重构了整个架构。本节我们聊聊v15，看看他为什么不能满足<strong>快速响应</strong>的理念，以至于被重构。</p><h2 id="react15架构" tabindex="-1"><a class="header-anchor" href="#react15架构" aria-hidden="true">#</a> React15架构</h2><p>React15架构可以分为两层：</p><ul><li>Reconciler（协调器）—— 负责找出变化的组件</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul><h3 id="reconciler-协调器" tabindex="-1"><a class="header-anchor" href="#reconciler-协调器" aria-hidden="true">#</a> Reconciler（协调器）</h3><p>我们知道，在<code>React</code>中可以通过<code>this.setState</code>、<code>this.forceUpdate</code>、<code>ReactDOM.render</code>等API触发更新。</p><p>每当有更新发生时，<strong>Reconciler</strong>会做如下工作：</p><ul><li>调用函数组件、或class组件的<code>render</code>方法，将返回的JSX转化为虚拟DOM</li><li>将虚拟DOM和上次更新时的虚拟DOM对比</li><li>通过对比找出本次更新中变化的虚拟DOM</li><li>通知<strong>Renderer</strong>将变化的虚拟DOM渲染到页面上</li></ul>',9),u={href:"https://zh-hans.reactjs.org/docs/codebase-overview.html#reconcilers",target:"_blank",rel:"noopener noreferrer"},g=e("code",null,"React",-1),m=e("strong",null,"Reconciler",-1),R=e("h3",{id:"renderer-渲染器",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#renderer-渲染器","aria-hidden":"true"},"#"),t(" Renderer（渲染器）")],-1),f=e("code",null,"React",-1),b=e("strong",null,"Renderer",-1),k=e("strong",null,"Renderer",-1),w={href:"https://www.npmjs.com/package/react-dom",target:"_blank",rel:"noopener noreferrer"},v=e("p",null,"除此之外，还有：",-1),D={href:"https://www.npmjs.com/package/react-native",target:"_blank",rel:"noopener noreferrer"},M={href:"https://www.npmjs.com/package/react-test-renderer",target:"_blank",rel:"noopener noreferrer"},O={href:"https://www.npmjs.com/package/react-art",target:"_blank",rel:"noopener noreferrer"},x=e("p",null,[t("在每次更新发生时，"),e("strong",null,"Renderer"),t("接到"),e("strong",null,"Reconciler"),t("通知，将变化的组件渲染在当前宿主环境。")],-1),C={href:"https://zh-hans.reactjs.org/docs/codebase-overview.html#renderers",target:"_blank",rel:"noopener noreferrer"},j=e("code",null,"React",-1),L=e("strong",null,"Renderer",-1),B=e("h2",{id:"react15架构的缺点",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#react15架构的缺点","aria-hidden":"true"},"#"),t(" React15架构的缺点")],-1),V=e("strong",null,"Reconciler",-1),E=e("code",null,"mount",-1),N={href:"https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L498",target:"_blank",rel:"noopener noreferrer"},I=e("code",null,"update",-1),S={href:"https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L877",target:"_blank",rel:"noopener noreferrer"},A=e("h3",{id:"递归更新的缺点",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#递归更新的缺点","aria-hidden":"true"},"#"),t(" 递归更新的缺点")],-1),J=e("p",null,"由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了16ms，用户交互就会卡顿。",-1),$=e("p",null,[t("在上一节中，我们已经提出了解决办法——用"),e("strong",null,"可中断的异步更新"),t("代替"),e("strong",null,"同步的更新"),t("。那么React15的架构支持异步更新么？让我们看一个例子：")],-1),q={class:"hint-container details"},z=e("summary",null,"乘法小Demo",-1),T=e("strong",null,"222",-1),X=e("p",null,[t("初始化时"),e("code",null,"state.count = 1"),t("，每次点击按钮"),e("code",null,"state.count++")],-1),y=e("p",null,[t("列表中3个元素的值分别为1，2，3乘以"),e("code",null,"state.count"),t("的结果")],-1),F=["src"],G=r('<p>我们可以看到，<strong>Reconciler</strong>和<strong>Renderer</strong>是交替工作的，当第一个<code>li</code>在页面上已经变化后，第二个<code>li</code>再进入<strong>Reconciler</strong>。</p><p>由于整个过程都是同步的，所以在用户看来所有DOM是同时更新的。</p><p>接下来，让我们模拟一下，如果中途中断更新会怎么样？</p><div class="hint-container danger"><p class="hint-container-title">注意</p><p>以下是我们模拟中断的情况，实际上<code>React15</code>并不会中断进行中的更新</p></div>',4),P=["src"],U=r("<p>当第一个<code>li</code>完成更新时中断更新，即步骤3完成后中断更新，此时后面的步骤都还未执行。</p><p>用户本来期望<code>123</code>变为<code>246</code>。实际却看见更新不完全的DOM！（即<code>223</code>）</p><p>基于这个原因，<code>React</code>决定重写整个架构。</p>",3);function Y(c,Z){const n=s("ExternalLinkIcon"),l=s("RouterLink");return d(),i("div",null,[p,e("blockquote",null,[e("p",null,[t("你可以在"),e("a",u,[t("这里"),o(n)]),t("看到"),g,t("官方对"),m,t("的解释")])]),R,e("p",null,[t("由于"),f,t("支持跨平台，所以不同平台有不同的"),b,t("。我们前端最熟悉的是负责在浏览器环境渲染的"),k,t(" —— "),e("a",w,[t("ReactDOM"),o(n)]),t("。")]),v,e("ul",null,[e("li",null,[e("a",D,[t("ReactNative"),o(n)]),t("渲染器，渲染App原生组件")]),e("li",null,[e("a",M,[t("ReactTest"),o(n)]),t("渲染器，渲染出纯Js对象用于测试")]),e("li",null,[e("a",O,[t("ReactArt"),o(n)]),t("渲染器，渲染到Canvas, SVG 或 VML (IE8)")])]),x,e("blockquote",null,[e("p",null,[t("你可以在"),e("a",C,[t("这里"),o(n)]),t("看到"),j,t("官方对"),L,t("的解释")])]),B,e("p",null,[t("在"),V,t("中，"),E,t("的组件会调用"),e("a",N,[t("mountComponent"),o(n)]),t("，"),I,t("的组件会调用"),e("a",S,[t("updateComponent"),o(n)]),t("。这两个方法都会递归更新子组件。")]),A,J,$,e("details",q,[z,e("p",null,[o(l,{to:"/views/Books/Front-end/JustReact/me.html"},{default:h(()=>[t("关注公众号")]),_:1}),t("，后台回复"),T,t("获得在线Demo地址")]),X,y]),e("p",null,[t("我用红色标注了更新的步骤。 "),e("img",{src:c.$withBase("/img/v15.png"),alt:"更新流程"},null,8,F)]),G,e("img",{src:c.$withBase("/img/dist.png"),alt:"中断更新流程"},null,8,P),U])}const K=a(_,[["render",Y],["__file","oldConstructure.html.vue"]]);export{K as default};
