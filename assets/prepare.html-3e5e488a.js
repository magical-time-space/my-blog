import{_ as p,X as r,Y as l,Z as n,$ as e,a0 as o,a5 as t,a4 as s,E as d}from"./framework-d8252107.js";const u={},i=n("code",null,"React",-1),h=n("code",null,"Legacy Mode",-1),k=n("code",null,"ReactDOM.render",-1),_={href:"https://mp.weixin.qq.com/s/zrrqldzRbcPApga_Cp2b8A",target:"_blank",rel:"noopener noreferrer"},b=n("code",null,"v17.0",-1),f=n("code",null,"v17.0",-1),m=n("code",null,"Concurrent Mode",-1),v=n("code",null,"v17",-1),g={href:"https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html",target:"_blank",rel:"noopener noreferrer"},x=s('<p>一句话概括：</p><blockquote><p>Concurrent 模式是一组 React 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。</p></blockquote><p><code>Concurrent Mode</code>是<code>React</code>过去2年重构<code>Fiber架构</code>的源动力，也是<code>React</code>未来的发展方向。</p><p>可以预见，当<code>v17</code>完美支持<code>Concurrent Mode</code>后，<code>v18</code>会迎来一大波基于<code>Concurrent Mode</code>的库。</p><p>底层基础决定了上层<code>API</code>的实现，接下来让我们了解下，<code>Concurrent Mode</code>自底向上都包含哪些组成部分，能够发挥哪些能力？</p><h2 id="底层架构-——-fiber架构" tabindex="-1"><a class="header-anchor" href="#底层架构-——-fiber架构" aria-hidden="true">#</a> 底层架构 —— Fiber架构</h2>',6),M=n("code",null,"Concurrent Mode",-1),C=s('<p>基于这个前提，<code>React</code>花费2年时间重构完成了<code>Fiber</code>架构。</p><p><code>Fiber</code>架构的意义在于，他将单个<code>组件</code>作为<code>工作单元</code>，使以<code>组件</code>为粒度的“异步可中断的更新”成为可能。</p><h2 id="架构的驱动力-——-scheduler" tabindex="-1"><a class="header-anchor" href="#架构的驱动力-——-scheduler" aria-hidden="true">#</a> 架构的驱动力 —— Scheduler</h2><p>如果我们同步运行<code>Fiber</code>架构（通过<code>ReactDOM.render</code>），则<code>Fiber</code>架构与重构前并无区别。</p><p>但是当我们配合<code>时间切片</code>，就能根据宿主环境性能，为每个<code>工作单元</code>分配一个<code>可运行时间</code>，实现“异步可中断的更新”。</p>',5),R={href:"https://github.com/facebook/react/tree/master/packages/scheduler",target:"_blank",rel:"noopener noreferrer"},y=s(`<h2 id="架构运行策略-——-lane模型" tabindex="-1"><a class="header-anchor" href="#架构运行策略-——-lane模型" aria-hidden="true">#</a> 架构运行策略 —— lane模型</h2><p>到目前为止，<code>React</code>可以控制<code>更新</code>在<code>Fiber</code>架构中运行/中断/继续运行。</p><p>基于当前的架构，当一次<code>更新</code>在运行过程中被中断，过段时间再继续运行，这就是“异步可中断的更新”。</p><p>当一次<code>更新</code>在运行过程中被中断，转而重新开始一次新的<code>更新</code>，我们可以说：后一次<code>更新</code>打断了前一次<code>更新</code>。</p><p>这就是<code>优先级</code>的概念：后一次<code>更新</code>的<code>优先级</code>更高，他打断了正在进行的前一次<code>更新</code>。</p><p>多个<code>优先级</code>之间如何互相打断？<code>优先级</code>能否升降？本次<code>更新</code>应该赋予什么<code>优先级</code>？</p><p>这就需要一个模型控制不同<code>优先级</code>之间的关系与行为，于是<code>lane</code>模型诞生了。</p><h2 id="上层实现" tabindex="-1"><a class="header-anchor" href="#上层实现" aria-hidden="true">#</a> 上层实现</h2><p>现在，我们可以说：</p><blockquote><p>从源码层面讲，Concurrent Mode是一套可控的“多优先级更新架构”。</p></blockquote><p>那么基于该架构之上可以实现哪些有意思的功能？我们举几个例子：</p><h3 id="batchedupdates" tabindex="-1"><a class="header-anchor" href="#batchedupdates" aria-hidden="true">#</a> batchedUpdates</h3><p>如果我们在一次事件回调中触发多次<code>更新</code>，他们会被合并为一次<code>更新</code>进行处理。</p><p>如下代码执行只会触发一次<code>更新</code>：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">stateA</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">stateB</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">stateA</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种合并多个<code>更新</code>的优化方式被称为<code>batchedUpdates</code>。</p><p><code>batchedUpdates</code>在很早的版本就存在了，不过之前的实现局限很多（脱离当前上下文环境的<code>更新</code>不会被合并）。</p><p>在<code>Concurrent Mode</code>中，是以<code>优先级</code>为依据对更新进行合并的，使用范围更广。</p><h3 id="suspense" tabindex="-1"><a class="header-anchor" href="#suspense" aria-hidden="true">#</a> Suspense</h3>`,19),V={href:"https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html",target:"_blank",rel:"noopener noreferrer"},B=n("code",null,"pending",-1),D=n("p",null,[e("本质上讲"),n("code",null,"Suspense"),e("内的组件子树比组件树的其他部分拥有更低的"),n("code",null,"优先级"),e("。")],-1),E=n("h3",{id:"usedeferredvalue",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#usedeferredvalue","aria-hidden":"true"},"#"),e(" useDeferredValue")],-1),F={href:"https://zh-hans.reactjs.org/docs/concurrent-mode-reference.html#usedeferredvalue",target:"_blank",rel:"noopener noreferrer"},j=n("code",null,"timeoutMs",-1),S=s(`<p>例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> deferredValue <span class="token operator">=</span> <span class="token function">useDeferredValue</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">timeoutMs</span><span class="token operator">:</span> <span class="token number">2000</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在<code>useDeferredValue</code>内部会调用<code>useState</code>并触发一次<code>更新</code>。</p><p>这次<code>更新</code>的<code>优先级</code>很低，所以当前如果有正在进行中的<code>更新</code>，不会受<code>useDeferredValue</code>产生的<code>更新</code>影响。所以<code>useDeferredValue</code>能够返回延迟的值。</p><p>当超过<code>timeoutMs</code>后<code>useDeferredValue</code>产生的<code>更新</code>还没进行（由于<code>优先级</code>太低一直被打断），则会再触发一次高优先级<code>更新</code>。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>除了以上介绍的实现，相信未来<code>React</code>还会开发更多基于<code>Concurrent Mode</code>的玩法。</p><p><code>Fiber</code>架构在之前的章节已经学习了。所以，在本章接下来的部分，我们会按照上文的脉络，自底向上，从架构到实现讲解<code>Concurrent Mode</code>。</p>`,8);function w(A,q){const c=d("RouterLink"),a=d("ExternalLinkIcon");return r(),l("div",null,[n("p",null,[e("在"),o(c,{to:"/views/Books/Front-end/JustReact/state/reactdom.html#react%E7%9A%84%E5%85%B6%E4%BB%96%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"},{default:t(()=>[e("ReactDOM.render")]),_:1}),e("一节我们介绍了"),i,e("当前的三种入口函数。日常开发主要使用的是"),h,e("（通过"),k,e("创建）。")]),n("p",null,[e("从"),n("a",_,[e("React v17.0 正式发布！"),o(a)]),e("一文可以看到，"),b,e("没有包含新特性。究其原因，"),f,e("主要的工作在于源码内部对"),m,e("的支持。所以"),v,e("版本也被称为“垫脚石”版本。")]),n("p",null,[e("你可以从官网"),n("a",g,[e("Concurrent 模式介绍"),o(a)]),e("了解其基本概念。")]),x,n("p",null,[e("从"),o(c,{to:"/views/Books/Front-end/JustReact/preparation/idea.html"},{default:t(()=>[e("设计理念")]),_:1}),e("我们了解到要实现"),M,e("，最关键的一点是：实现异步可中断的更新。")]),C,n("p",null,[e("于是，"),n("a",R,[e("scheduler"),o(a)]),e("（调度器）产生了。")]),y,n("p",null,[n("a",V,[e("Suspense"),o(a)]),e("可以在组件请求数据时展示一个"),B,e("状态。请求成功后渲染数据。")]),D,E,n("p",null,[n("a",F,[e("useDeferredValue"),o(a)]),e("返回一个延迟响应的值，该值可能“延后”的最长时间为"),j,e("。")]),S])}const L=p(u,[["render",w],["__file","prepare.html.vue"]]);export{L as default};
