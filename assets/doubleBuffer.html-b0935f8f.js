const e=JSON.parse('{"key":"v-a343a516","path":"/views/Books/Front-end/JustReact/process/doubleBuffer.html","title":"","lang":"zh-CN","frontmatter":{"description":"通过上一节的学习，我们了解了Fiber是什么，知道Fiber节点可以保存对应的DOM节点。 相应的，Fiber节点构成的Fiber树就对应DOM树。 那么如何更新DOM呢？这需要用到被称为“双缓存”的技术。 什么是“双缓存” 当我们用canvas绘制动画，每一帧绘制前都会调用ctx.clearRect清除上一帧的画面。","head":[["meta",{"property":"og:url","content":"https://mpbug.gitee.io/views/Books/Front-end/JustReact/process/doubleBuffer.html"}],["meta",{"property":"og:site_name","content":"魔法Bug"}],["meta",{"property":"og:description","content":"通过上一节的学习，我们了解了Fiber是什么，知道Fiber节点可以保存对应的DOM节点。 相应的，Fiber节点构成的Fiber树就对应DOM树。 那么如何更新DOM呢？这需要用到被称为“双缓存”的技术。 什么是“双缓存” 当我们用canvas绘制动画，每一帧绘制前都会调用ctx.clearRect清除上一帧的画面。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"魔法时空宝库"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"魔法时空宝库\\",\\"url\\":\\"https://mpbug.gitee.io/player/\\"}]}"]]},"headers":[{"level":2,"title":"什么是“双缓存”","slug":"什么是-双缓存","link":"#什么是-双缓存","children":[]},{"level":2,"title":"双缓存Fiber树","slug":"双缓存fiber树","link":"#双缓存fiber树","children":[]},{"level":2,"title":"mount时","slug":"mount时","link":"#mount时","children":[]},{"level":2,"title":"update时","slug":"update时","link":"#update时","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{},"readingTime":{"minutes":3.83,"words":1149},"filePathRelative":"views/Books/Front-end/JustReact/process/doubleBuffer.md","excerpt":"<p>通过上一节的学习，我们了解了<code>Fiber</code>是什么，知道<code>Fiber节点</code>可以保存对应的<code>DOM节点</code>。</p>\\n<p>相应的，<code>Fiber节点</code>构成的<code>Fiber树</code>就对应<code>DOM树</code>。</p>\\n<p>那么如何更新<code>DOM</code>呢？这需要用到被称为“双缓存”的技术。</p>\\n<h2> 什么是“双缓存”</h2>\\n<p>当我们用<code>canvas</code>绘制动画，每一帧绘制前都会调用<code>ctx.clearRect</code>清除上一帧的画面。</p>","autoDesc":true}');export{e as data};
