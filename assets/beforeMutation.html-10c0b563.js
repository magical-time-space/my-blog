import{_ as i,X as l,Y as d,Z as e,$ as n,a0 as s,a5 as c,a4 as a,E as p}from"./framework-d8252107.js";const u={},r=a('<p>在本节正式开始前，让我们复习下这一章到目前为止所学的。</p><p><code>Renderer</code>工作的阶段被称为<code>commit</code>阶段。<code>commit</code>阶段可以分为三个子阶段：</p><ul><li><p>before mutation阶段（执行<code>DOM</code>操作前）</p></li><li><p>mutation阶段（执行<code>DOM</code>操作）</p></li><li><p>layout阶段（执行<code>DOM</code>操作后）</p></li></ul><p>本节我们看看<code>before mutation阶段</code>（执行<code>DOM</code>操作前）都做了什么。</p><h2 id="概览" tabindex="-1"><a class="header-anchor" href="#概览" aria-hidden="true">#</a> 概览</h2><p><code>before mutation阶段</code>的代码很短，整个过程就是遍历<code>effectList</code>并调用<code>commitBeforeMutationEffects</code>函数处理。</p>',6),f={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2104-L2127",target:"_blank",rel:"noopener noreferrer"},k=a(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级</span>
<span class="token keyword">const</span> previousLanePriority <span class="token operator">=</span> <span class="token function">getCurrentUpdateLanePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setCurrentUpdateLanePriority</span><span class="token punctuation">(</span>SyncLanePriority<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 将当前上下文标记为CommitContext，作为commit阶段的标志</span>
<span class="token keyword">const</span> prevExecutionContext <span class="token operator">=</span> executionContext<span class="token punctuation">;</span>
executionContext <span class="token operator">|=</span> CommitContext<span class="token punctuation">;</span>

<span class="token comment">// 处理focus状态</span>
focusedInstanceHandle <span class="token operator">=</span> <span class="token function">prepareForCommit</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>containerInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
shouldFireAfterActiveInstanceBlur <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token comment">// beforeMutation阶段的主函数</span>
<span class="token function">commitBeforeMutationEffects</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>

focusedInstanceHandle <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们重点关注<code>beforeMutation</code>阶段的主函数<code>commitBeforeMutationEffects</code>做了什么。</p><h2 id="commitbeforemutationeffects" tabindex="-1"><a class="header-anchor" href="#commitbeforemutationeffects" aria-hidden="true">#</a> commitBeforeMutationEffects</h2><p>大体代码逻辑：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">commitBeforeMutationEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldFireAfterActiveInstanceBlur <span class="token operator">&amp;&amp;</span> focusedInstanceHandle <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...focus blur相关</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> effectTag <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>effectTag<span class="token punctuation">;</span>

    <span class="token comment">// 调用getSnapshotBeforeUpdate</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Snapshot<span class="token punctuation">)</span> <span class="token operator">!==</span> NoEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">commitBeforeMutationEffectOnFiber</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 调度useEffect</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Passive<span class="token punctuation">)</span> <span class="token operator">!==</span> NoEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>NormalSchedulerPriority<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">flushPassiveEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    nextEffect <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>nextEffect<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整体可以分为三部分：</p><ol><li><p>处理<code>DOM节点</code>渲染/删除后的 <code>autoFocus</code>、<code>blur</code> 逻辑。</p></li><li><p>调用<code>getSnapshotBeforeUpdate</code>生命周期钩子。</p></li><li><p>调度<code>useEffect</code>。</p></li></ol><p>我们讲解下2、3两点。</p><h2 id="调用getsnapshotbeforeupdate" tabindex="-1"><a class="header-anchor" href="#调用getsnapshotbeforeupdate" aria-hidden="true">#</a> 调用getSnapshotBeforeUpdate</h2><p><code>commitBeforeMutationEffectOnFiber</code>是<code>commitBeforeMutationLifeCycles</code>的别名。</p><p>在该方法内会调用<code>getSnapshotBeforeUpdate</code>。</p>`,11),v={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L222",target:"_blank",rel:"noopener noreferrer"},m=a("<p>从<code>React</code>v16开始，<code>componentWillXXX</code>钩子前增加了<code>UNSAFE_</code>前缀。</p><p>究其原因，是因为<code>Stack Reconciler</code>重构为<code>Fiber Reconciler</code>后，<code>render阶段</code>的任务可能中断/重新开始，对应的组件在<code>render阶段</code>的生命周期钩子（即<code>componentWillXXX</code>）可能触发多次。</p><p>这种行为和<code>React</code>v15不一致，所以标记为<code>UNSAFE_</code>。</p>",3),b={href:"https://juejin.im/post/6847902224287285255#comment",target:"_blank",rel:"noopener noreferrer"},h=a(`<p>为此，<code>React</code>提供了替代的生命周期钩子<code>getSnapshotBeforeUpdate</code>。</p><p>我们可以看见，<code>getSnapshotBeforeUpdate</code>是在<code>commit阶段</code>内的<code>before mutation阶段</code>调用的，由于<code>commit阶段</code>是同步的，所以不会遇到多次调用的问题。</p><h2 id="调度useeffect" tabindex="-1"><a class="header-anchor" href="#调度useeffect" aria-hidden="true">#</a> 调度<code>useEffect</code></h2><p>在这几行代码内，<code>scheduleCallback</code>方法由<code>Scheduler</code>模块提供，用于以某个优先级异步调度一个回调函数。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 调度useEffect</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Passive<span class="token punctuation">)</span> <span class="token operator">!==</span> NoEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>NormalSchedulerPriority<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 触发useEffect</span>
      <span class="token function">flushPassiveEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此处，被异步调度的回调函数就是触发<code>useEffect</code>的方法<code>flushPassiveEffects</code>。</p><p>我们接下来讨论<code>useEffect</code>如何被异步调度，以及为什么要异步（而不是同步）调度。</p><h3 id="如何异步调度" tabindex="-1"><a class="header-anchor" href="#如何异步调度" aria-hidden="true">#</a> 如何异步调度</h3><p>在<code>flushPassiveEffects</code>方法内部会从全局变量<code>rootWithPendingPassiveEffects</code>获取<code>effectList</code>。</p>`,9),E=e("code",null,"flushPassiveEffects",-1),_=e("code",null,"effectList",-1),g=e("code",null,"Fiber节点",-1),P=a("<ul><li>插入<code>DOM节点</code>（Placement）</li><li>更新<code>DOM节点</code>（Update）</li><li>删除<code>DOM节点</code>（Deletion）</li></ul><p>除此外，当一个<code>FunctionComponent</code>含有<code>useEffect</code>或<code>useLayoutEffect</code>，他对应的<code>Fiber节点</code>也会被赋值<code>effectTag</code>。</p>",2),y={href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactHookEffectTags.js",target:"_blank",rel:"noopener noreferrer"},x=e("code",null,"hook",-1),w=e("code",null,"effectTag",-1),L=a(`<p>在<code>flushPassiveEffects</code>方法内部会遍历<code>rootWithPendingPassiveEffects</code>（即<code>effectList</code>）执行<code>effect</code>回调函数。</p><p>如果在此时直接执行，<code>rootWithPendingPassiveEffects === null</code>。</p><p>那么<code>rootWithPendingPassiveEffects</code>会在何时赋值呢？</p><p>在上一节<code>layout之后</code>的代码片段中会根据<code>rootDoesHavePassiveEffects === true?</code>决定是否赋值<code>rootWithPendingPassiveEffects</code>。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> rootDidHavePassiveEffects <span class="token operator">=</span> rootDoesHavePassiveEffects<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  rootWithPendingPassiveEffects <span class="token operator">=</span> root<span class="token punctuation">;</span>
  pendingPassiveEffectsLanes <span class="token operator">=</span> lanes<span class="token punctuation">;</span>
  pendingPassiveEffectsRenderPriority <span class="token operator">=</span> renderPriorityLevel<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以整个<code>useEffect</code>异步调用分为三步：</p><ol><li><code>before mutation阶段</code>在<code>scheduleCallback</code>中调度<code>flushPassiveEffects</code></li><li><code>layout阶段</code>之后将<code>effectList</code>赋值给<code>rootWithPendingPassiveEffects</code></li><li><code>scheduleCallback</code>触发<code>flushPassiveEffects</code>，<code>flushPassiveEffects</code>内部遍历<code>rootWithPendingPassiveEffects</code></li></ol><h3 id="为什么需要异步调用" tabindex="-1"><a class="header-anchor" href="#为什么需要异步调用" aria-hidden="true">#</a> 为什么需要异步调用</h3>`,8),B=e("code",null,"React",-1),M={href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#timing-of-effects",target:"_blank",rel:"noopener noreferrer"},D=a('<blockquote><p>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p></blockquote><p>可见，<code>useEffect</code>异步执行的原因主要是防止同步执行时阻塞浏览器渲染。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>经过本节学习，我们知道了在<code>before mutation阶段</code>，会遍历<code>effectList</code>，依次执行：</p><ol><li><p>处理<code>DOM节点</code>渲染/删除后的 <code>autoFocus</code>、<code>blur</code>逻辑</p></li><li><p>调用<code>getSnapshotBeforeUpdate</code>生命周期钩子</p></li><li><p>调度<code>useEffect</code></p></li></ol>',5);function C(j,F){const o=p("ExternalLinkIcon"),t=p("RouterLink");return l(),d("div",null,[r,e("blockquote",null,[e("p",null,[n("这部分"),e("a",f,[n("源码在这里"),s(o)]),n("。为了增加可读性，示例代码中删除了不相关的逻辑")])]),k,e("blockquote",null,[e("p",null,[n("你可以在"),e("a",v,[n("这里"),s(o)]),n("看到这段逻辑")])]),m,e("blockquote",null,[e("p",null,[n("更详细的解释参照"),e("a",b,[n("这里"),s(o)])])]),h,e("p",null,[n("关于"),E,n("的具体讲解参照"),s(t,{to:"/views/Books/Front-end/JustReact/hooks/useeffect.html"},{default:c(()=>[n("useEffect与useLayoutEffect一节")]),_:1})]),e("p",null,[n("在"),s(t,{to:"/views/Books/Front-end/JustReact/process/completeWork.html#effectlist"},{default:c(()=>[n("completeWork一节")]),_:1}),n("我们讲到，"),_,n("中保存了需要执行副作用的"),g,n("。其中副作用包括")]),P,e("blockquote",null,[e("p",null,[n("你可以从"),e("a",y,[n("这里"),s(o)]),n("看到"),x,n("相关的"),w])]),L,e("p",null,[n("摘录自"),B,n("文档"),e("a",M,[n("effect 的执行时机"),s(o)]),n("：")]),D])}const R=i(u,[["render",C],["__file","beforeMutation.html.vue"]]);export{R as default};
