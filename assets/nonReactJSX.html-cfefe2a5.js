const e=JSON.parse('{"key":"v-b67a5fa6","path":"/views/Books/Front-end/TypescriptMaster/jsx/nonReactJSX.html","title":"非 React JSX","lang":"zh-CN","frontmatter":{"description":"非 React JSX TypeScript 让你能够以类型安全的方式，在 React 中使用 JSX 之外的其他东西。下面列出了一些可自定义的点，但请注意，这只适用于高级 UI 框架的作者。 你可以使用 \\"jsx\\":\\"preserve\\" 选项来禁用 React 的样式触发。这意味着，JSX 将按原样被触发，然后你可以使用自定义转化器来转化 JSX 部分。 使用 JSX 全局模块： 你可以通过定制 JSX.IntrinsicElements 的接口成员来控制哪些 HTML 标签是可用的，以及如何对其进行类型检查； 当你在组件中使用时： 你可以通过自定义默认的 interface ElementClass extends React.Component&lt;any, any&gt; { } 声明文件来控制哪个 class 必须由组件继承； 你可以通过自定义 declare module JSX { interface ElementAttributesProperty { props: {} } } 声明文件来控制使用的哪个属性（property）来检查特性（attribute）（默认是 props）。","head":[["meta",{"property":"og:url","content":"https://mpbug.gitee.io/views/Books/Front-end/TypescriptMaster/jsx/nonReactJSX.html"}],["meta",{"property":"og:site_name","content":"魔法Bug"}],["meta",{"property":"og:title","content":"非 React JSX"}],["meta",{"property":"og:description","content":"非 React JSX TypeScript 让你能够以类型安全的方式，在 React 中使用 JSX 之外的其他东西。下面列出了一些可自定义的点，但请注意，这只适用于高级 UI 框架的作者。 你可以使用 \\"jsx\\":\\"preserve\\" 选项来禁用 React 的样式触发。这意味着，JSX 将按原样被触发，然后你可以使用自定义转化器来转化 JSX 部分。 使用 JSX 全局模块： 你可以通过定制 JSX.IntrinsicElements 的接口成员来控制哪些 HTML 标签是可用的，以及如何对其进行类型检查； 当你在组件中使用时： 你可以通过自定义默认的 interface ElementClass extends React.Component&lt;any, any&gt; { } 声明文件来控制哪个 class 必须由组件继承； 你可以通过自定义 declare module JSX { interface ElementAttributesProperty { props: {} } } 声明文件来控制使用的哪个属性（property）来检查特性（attribute）（默认是 props）。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"魔法时空宝库"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"非 React JSX\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"魔法时空宝库\\",\\"url\\":\\"https://mpbug.gitee.io/player/\\"}]}"]]},"headers":[{"level":2,"title":"jsxFactory","slug":"jsxfactory","link":"#jsxfactory","children":[{"level":3,"title":"例子","slug":"例子","link":"#例子","children":[]},{"level":3,"title":"jsx 编译提示","slug":"jsx-编译提示","link":"#jsx-编译提示","children":[]}]}],"git":{},"readingTime":{"minutes":1.35,"words":406},"filePathRelative":"views/Books/Front-end/TypescriptMaster/jsx/nonReactJSX.md","excerpt":"<h1> 非 React JSX</h1>\\n<p>TypeScript 让你能够以类型安全的方式，在 React 中使用 JSX 之外的其他东西。下面列出了一些可自定义的点，但请注意，这只适用于高级 UI 框架的作者。</p>\\n<ul>\\n<li>你可以使用 <code>\\"jsx\\":\\"preserve\\"</code> 选项来禁用 React 的样式触发。这意味着，JSX 将按原样被触发，然后你可以使用自定义转化器来转化 JSX 部分。</li>\\n<li>使用 <code>JSX</code> 全局模块：\\n<ul>\\n<li>你可以通过定制 <code>JSX.IntrinsicElements</code> 的接口成员来控制哪些 HTML 标签是可用的，以及如何对其进行类型检查；</li>\\n<li>当你在组件中使用时：\\n<ul>\\n<li>你可以通过自定义默认的 <code>interface ElementClass extends React.Component&lt;any, any&gt; { }</code> 声明文件来控制哪个 <code>class</code> 必须由组件继承；</li>\\n<li>你可以通过自定义 <code>declare module JSX { interface ElementAttributesProperty { props: {} } }</code> 声明文件来控制使用的哪个属性（property）来检查特性（attribute）（默认是 <code>props</code>）。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
