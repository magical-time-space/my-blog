const e=JSON.parse('{"key":"v-42faecb7","path":"/views/Books/Front-end/TypescriptMaster/typings/neverType.html","title":"Never","lang":"zh-CN","frontmatter":{"description":"Never 提示 一个关于 never 的介绍视频 程序语言的设计确实应该存在一个底部类型的概念，当你在分析代码流的时候，这会是一个理所当然存在的类型。TypeScript 就是这样一种分析代码流的语言（😎），因此它需要一个可靠的，代表永远不会发生的类型。","head":[["meta",{"property":"og:url","content":"https://mpbug.gitee.io/views/Books/Front-end/TypescriptMaster/typings/neverType.html"}],["meta",{"property":"og:site_name","content":"魔法Bug"}],["meta",{"property":"og:title","content":"Never"}],["meta",{"property":"og:description","content":"Never 提示 一个关于 never 的介绍视频 程序语言的设计确实应该存在一个底部类型的概念，当你在分析代码流的时候，这会是一个理所当然存在的类型。TypeScript 就是这样一种分析代码流的语言（😎），因此它需要一个可靠的，代表永远不会发生的类型。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"魔法时空宝库"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Never\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"魔法时空宝库\\",\\"url\\":\\"https://mpbug.gitee.io/player/\\"}]}"]]},"headers":[{"level":2,"title":"用例：详细的检查","slug":"用例-详细的检查","link":"#用例-详细的检查","children":[]},{"level":2,"title":"与 void 的差异","slug":"与-void-的差异","link":"#与-void-的差异","children":[]}],"git":{},"readingTime":{"minutes":2.05,"words":614},"filePathRelative":"views/Books/Front-end/TypescriptMaster/typings/neverType.md","excerpt":"<h1> Never</h1>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">提示</p>\\n<p><a href=\\"https://egghead.io/lessons/typescript-use-the-never-type-to-avoid-code-with-dead-ends-using-typescript\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">一个关于 never 的介绍视频</a></p>\\n</div>\\n<p>程序语言的设计确实应该存在一个底部类型的概念，当你在分析代码流的时候，这会是一个理所当然存在的类型。TypeScript 就是这样一种分析代码流的语言（😎），因此它需要一个可靠的，代表永远不会发生的类型。</p>","autoDesc":true}');export{e as data};
