import{_ as c,X as t,Y as p,Z as s,$ as n,a0 as e,a4 as o,E as d}from"./framework-d8252107.js";const i={},l={href:"https://github.com/sebmarkbage/",target:"_blank",rel:"noopener noreferrer"},r=s("code",null,"React Hooks",-1),u=s("code",null,"React",-1),k=s("code",null,"代数效应",-1),m=o(`<p>那么，<code>代数效应</code>是什么呢？他和<code>React</code>有什么关系呢。</p><h2 id="什么是代数效应" tabindex="-1"><a class="header-anchor" href="#什么是代数效应" aria-hidden="true">#</a> 什么是代数效应</h2><p><code>代数效应</code>是<code>函数式编程</code>中的一个概念，用于将<code>副作用</code>从<code>函数</code>调用中分离。</p><p>接下来我们用<code>虚构的语法</code>来解释。</p><p>假设我们有一个函数<code>getTotalPicNum</code>，传入2个<code>用户名称</code>后，分别查找该用户在平台保存的图片数量，最后将图片数量相加后返回。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">getTotalPicNum</span><span class="token punctuation">(</span><span class="token parameter">user1<span class="token punctuation">,</span> user2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> picNum1 <span class="token operator">=</span> <span class="token function">getPicNum</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> picNum2 <span class="token operator">=</span> <span class="token function">getPicNum</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> picNum1 <span class="token operator">+</span> picNum2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>getTotalPicNum</code>中，我们不关注<code>getPicNum</code>的实现，只在乎“获取到两个数字后将他们相加的结果返回”这一过程。</p><p>接下来我们来实现<code>getPicNum</code>。</p><p>&quot;用户在平台保存的图片数量&quot;是保存在服务器中的。所以，为了获取该值，我们需要发起异步请求。</p><p>为了尽量保持<code>getTotalPicNum</code>的调用方式不变，我们首先想到了使用<code>async await</code>：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getTotalPicNum</span><span class="token punctuation">(</span><span class="token parameter">user1<span class="token punctuation">,</span> user2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> picNum1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getPicNum</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> picNum2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getPicNum</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> picNum1 <span class="token operator">+</span> picNum2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，<code>async await</code>是有<code>传染性</code>的 —— 当一个函数变为<code>async</code>后，这意味着调用他的函数也需要是<code>async</code>，这破坏了<code>getTotalPicNum</code>的同步特性。</p><p>有没有什么办法能保持<code>getTotalPicNum</code>保持现有调用方式不变的情况下实现异步请求呢？</p><p>没有。不过我们可以<code>虚构</code>一个。</p><p>我们虚构一个类似<code>try...catch</code>的语法 —— <code>try...handle</code>与两个操作符<code>perform</code>、<code>resume</code>。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">getPicNum</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> picNum <span class="token operator">=</span> perform name<span class="token punctuation">;</span>
  <span class="token keyword">return</span> picNum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token function">getTotalPicNum</span><span class="token punctuation">(</span><span class="token string">&#39;kaSong&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;xiaoMing&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token function">handle</span> <span class="token punctuation">(</span><span class="token parameter">who</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>who<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">&#39;kaSong&#39;</span><span class="token operator">:</span>
      resume <span class="token keyword">with</span> <span class="token number">230</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">&#39;xiaoMing&#39;</span><span class="token operator">:</span>
      resume <span class="token keyword">with</span> <span class="token number">122</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      resume <span class="token keyword">with</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当执行到<code>getTotalPicNum</code>内部的<code>getPicNum</code>方法时，会执行<code>perform name</code>。</p><p>此时函数调用栈会从<code>getPicNum</code>方法内跳出，被最近一个<code>try...handle</code>捕获。类似<code>throw Error</code>后被最近一个<code>try...catch</code>捕获。</p><p>类似<code>throw Error</code>后<code>Error</code>会作为<code>catch</code>的参数，<code>perform name</code>后<code>name</code>会作为<code>handle</code>的参数。</p><p>与<code>try...catch</code>最大的不同在于：当<code>Error</code>被<code>catch</code>捕获后，之前的调用栈就销毁了。而<code>handle</code>执行<code>resume</code>后会回到之前<code>perform</code>的调用栈。</p><p>对于<code>case &#39;kaSong&#39;</code>，执行完<code>resume with 230;</code>后调用栈会回到<code>getPicNum</code>，此时<code>picNum === 230</code></p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>再次申明，<code>try...handle</code>的语法是虚构的，只是为了演示<code>代数效应</code>的思想。</p></div><p>总结一下：<code>代数效应</code>能够将<code>副作用</code>（例子中为<code>请求图片数量</code>）从函数逻辑中分离，使函数关注点保持纯粹。</p><p>并且，从例子中可以看出，<code>perform resume</code>不需要区分同步异步。</p><h2 id="代数效应在react中的应用" tabindex="-1"><a class="header-anchor" href="#代数效应在react中的应用" aria-hidden="true">#</a> 代数效应在React中的应用</h2><p>那么<code>代数效应</code>与<code>React</code>有什么关系呢？最明显的例子就是<code>Hooks</code>。</p><p>对于类似<code>useState</code>、<code>useReducer</code>、<code>useRef</code>这样的<code>Hook</code>，我们不需要关注<code>FunctionComponent</code>的<code>state</code>在<code>Hook</code>中是如何保存的，<code>React</code>会为我们处理。</p><p>我们只需要假设<code>useState</code>返回的是我们想要的<code>state</code>，并编写业务逻辑就行。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> updateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=&gt;</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>  
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,29),v={href:"https://codesandbox.io/s/frosty-hermann-bztrp?file=/src/index.js:152-160",target:"_blank",rel:"noopener noreferrer"},b=o(`<p>在<code>Demo</code>中<code>ProfileDetails</code>用于展示<code>用户名称</code>。而<code>用户名称</code>是<code>异步请求</code>的。</p><p>但是<code>Demo</code>中完全是<code>同步</code>的写法。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">ProfileDetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> resource<span class="token punctuation">.</span>user<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>user<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="代数效应与generator" tabindex="-1"><a class="header-anchor" href="#代数效应与generator" aria-hidden="true">#</a> 代数效应与Generator</h2><p>从<code>React15</code>到<code>React16</code>，协调器（<code>Reconciler</code>）重构的一大目的是：将老的<code>同步更新</code>的架构变为<code>异步可中断更新</code>。</p><p><code>异步可中断更新</code>可以理解为：<code>更新</code>在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。</p><p>这就是<code>代数效应</code>中<code>try...handle</code>的作用。</p><p>其实，浏览器原生就支持类似的实现，这就是<code>Generator</code>。</p><p>但是<code>Generator</code>的一些缺陷使<code>React</code>团队放弃了他：</p><ul><li><p>类似<code>async</code>，<code>Generator</code>也是<code>传染性</code>的，使用了<code>Generator</code>则上下文的其他函数也需要作出改变。这样心智负担比较重。</p></li><li><p><code>Generator</code>执行的<code>中间状态</code>是上下文关联的。</p></li></ul><p>考虑如下例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">doExpensiveWorkA</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token function">doExpensiveWorkB</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> z <span class="token operator">=</span> y <span class="token operator">+</span> <span class="token function">doExpensiveWorkC</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每当浏览器有空闲时间都会依次执行其中一个<code>doExpensiveWork</code>，当时间用尽则会中断，当再次恢复时会从中断位置继续执行。</p><p>只考虑“单一优先级任务的中断与继续”情况下<code>Generator</code>可以很好的实现<code>异步可中断更新</code>。</p><p>但是当我们考虑“高优先级任务插队”的情况，如果此时已经完成<code>doExpensiveWorkA</code>与<code>doExpensiveWorkB</code>计算出<code>x</code>与<code>y</code>。</p><p>此时<code>B</code>组件接收到一个<code>高优更新</code>，由于<code>Generator</code>执行的<code>中间状态</code>是上下文关联的，所以计算<code>y</code>时无法复用之前已经计算出的<code>x</code>，需要重新计算。</p><p>如果通过<code>全局变量</code>保存之前执行的<code>中间状态</code>，又会引入新的复杂度。</p>`,17),h={href:"https://github.com/facebook/react/issues/7942#issuecomment-254987818",target:"_blank",rel:"noopener noreferrer"},g=o('<p>基于这些原因，<code>React</code>没有采用<code>Generator</code>实现<code>协调器</code>。</p><h2 id="代数效应与fiber" tabindex="-1"><a class="header-anchor" href="#代数效应与fiber" aria-hidden="true">#</a> 代数效应与Fiber</h2><p><code>Fiber</code>并不是计算机术语中的新名词，他的中文翻译叫做<code>纤程</code>，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。</p><p>在很多文章中将<code>纤程</code>理解为<code>协程</code>的一种实现。在<code>JS</code>中，<code>协程</code>的实现便是<code>Generator</code>。</p><p>所以，我们可以将<code>纤程</code>(Fiber)、<code>协程</code>(Generator)理解为<code>代数效应</code>思想在<code>JS</code>中的体现。</p><p><code>React Fiber</code>可以理解为：</p><p><code>React</code>内部实现的一套状态更新机制。支持任务不同<code>优先级</code>，可中断与恢复，并且恢复后可以复用之前的<code>中间状态</code>。</p><p>其中每个任务更新单元为<code>React Element</code>对应的<code>Fiber节点</code>。</p><p>下一节，我们具体讲解<code>Fiber架构</code>的实现。</p>',9);function f(y,w){const a=d("ExternalLinkIcon");return t(),p("div",null,[s("p",null,[n("React核心团队成员"),s("a",l,[n("Sebastian Markbåge"),e(a)]),n("（"),r,n("的发明者）曾说：我们在"),u,n("中做的就是践行"),k,n("（Algebraic Effects）。")]),m,s("p",null,[n("如果这个例子还不够明显，可以看看官方的"),s("a",v,[n("Suspense Demo"),e(a)])]),b,s("blockquote",null,[s("p",null,[n("更详细的解释可以参考"),s("a",h,[n("这个issue"),e(a)])])]),g])}const _=c(i,[["render",f],["__file","fiber-mental.html.vue"]]);export{_ as default};
