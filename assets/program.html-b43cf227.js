import{_ as t,X as r,Y as a,Z as o,$ as e,a0 as d,a5 as s,a4 as i,E as n}from"./framework-d8252107.js";const l={},p=o("h1",{id:"程序",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#程序","aria-hidden":"true"},"#"),e(" 程序")],-1),m=o("code",null,"program.ts",-1),h=o("code",null,"Program",-1),_=o("code",null,"SourceFile",-1),u=i('<h2 id="compilerhost-的使用" tabindex="-1"><a class="header-anchor" href="#compilerhost-的使用" aria-hidden="true">#</a> <code>CompilerHost</code> 的使用</h2><p>CompilerHost 是与操作环境（OE, Operating Enviornment）进行交互的机制：</p><p><code>Program</code> <em>-使用-&gt;</em> <code>CompilerHost</code> <em>-使用-&gt;</em> <code>System</code></p><p>用 <code>CompilerHost</code> 作中间层的原因是可以让接口对 <code>Program</code> 的需求进行细粒度的调整，而无需考虑操作环境的需求。（例如：<code>Program</code> 无需关心 <code>System</code> 的 <code>fileExists</code> 函数）</p><p>对<code>System</code>而言还有其他的使用者（比如测试）</p><h2 id="sourcefile" tabindex="-1"><a class="header-anchor" href="#sourcefile" aria-hidden="true">#</a> SourceFile</h2><p>程序有个 API，用于获取 SourceFile：<code>getSourceFiles(): SourceFile[];</code>。得到的每个元素均是一棵抽象语法树的根节点（称做 <code>SourceFile</code>）</p>',7);function f(g,S){const c=n("RouterLink");return r(),a("div",null,[p,o("p",null,[e("程序定义在 "),m,e(" 中。"),d(c,{to:"/views/Books/Front-end/TypescriptMaster/project/compilationContext.html"},{default:s(()=>[e("编译上下文")]),_:1}),e("在 TypeScript 编译器中被视为一个 "),h,e("，它包含 "),_,e(" 和编译选项")]),u])}const C=t(l,[["render",f],["__file","program.html.vue"]]);export{C as default};
